// Code generated by protoc-gen-go-vtproto. DO NOT EDIT.
// protoc-gen-go-vtproto version: v0.6.1-0.20240409071808-615f978279ca
// source: validate/validate.proto

package validate

import (
	binary "encoding/binary"
	fmt "fmt"
	protohelpers "github.com/planetscale/vtprotobuf/protohelpers"
	durationpb1 "github.com/planetscale/vtprotobuf/types/known/durationpb"
	timestamppb1 "github.com/planetscale/vtprotobuf/types/known/timestamppb"
	proto "google.golang.org/protobuf/proto"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

func (m *FieldRules) CloneVT() *FieldRules {
	if m == nil {
		return (*FieldRules)(nil)
	}
	r := new(FieldRules)
	r.Message = m.Message.CloneVT()
	if m.Type != nil {
		r.Type = m.Type.(interface{ CloneVT() isFieldRules_Type }).CloneVT()
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *FieldRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *FieldRules_Float) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Float)(nil)
	}
	r := new(FieldRules_Float)
	r.Float = m.Float.CloneVT()
	return r
}

func (m *FieldRules_Double) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Double)(nil)
	}
	r := new(FieldRules_Double)
	r.Double = m.Double.CloneVT()
	return r
}

func (m *FieldRules_Int32) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Int32)(nil)
	}
	r := new(FieldRules_Int32)
	r.Int32 = m.Int32.CloneVT()
	return r
}

func (m *FieldRules_Int64) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Int64)(nil)
	}
	r := new(FieldRules_Int64)
	r.Int64 = m.Int64.CloneVT()
	return r
}

func (m *FieldRules_Uint32) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Uint32)(nil)
	}
	r := new(FieldRules_Uint32)
	r.Uint32 = m.Uint32.CloneVT()
	return r
}

func (m *FieldRules_Uint64) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Uint64)(nil)
	}
	r := new(FieldRules_Uint64)
	r.Uint64 = m.Uint64.CloneVT()
	return r
}

func (m *FieldRules_Sint32) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Sint32)(nil)
	}
	r := new(FieldRules_Sint32)
	r.Sint32 = m.Sint32.CloneVT()
	return r
}

func (m *FieldRules_Sint64) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Sint64)(nil)
	}
	r := new(FieldRules_Sint64)
	r.Sint64 = m.Sint64.CloneVT()
	return r
}

func (m *FieldRules_Fixed32) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Fixed32)(nil)
	}
	r := new(FieldRules_Fixed32)
	r.Fixed32 = m.Fixed32.CloneVT()
	return r
}

func (m *FieldRules_Fixed64) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Fixed64)(nil)
	}
	r := new(FieldRules_Fixed64)
	r.Fixed64 = m.Fixed64.CloneVT()
	return r
}

func (m *FieldRules_Sfixed32) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Sfixed32)(nil)
	}
	r := new(FieldRules_Sfixed32)
	r.Sfixed32 = m.Sfixed32.CloneVT()
	return r
}

func (m *FieldRules_Sfixed64) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Sfixed64)(nil)
	}
	r := new(FieldRules_Sfixed64)
	r.Sfixed64 = m.Sfixed64.CloneVT()
	return r
}

func (m *FieldRules_Bool) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Bool)(nil)
	}
	r := new(FieldRules_Bool)
	r.Bool = m.Bool.CloneVT()
	return r
}

func (m *FieldRules_String_) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_String_)(nil)
	}
	r := new(FieldRules_String_)
	r.String_ = m.String_.CloneVT()
	return r
}

func (m *FieldRules_Bytes) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Bytes)(nil)
	}
	r := new(FieldRules_Bytes)
	r.Bytes = m.Bytes.CloneVT()
	return r
}

func (m *FieldRules_Enum) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Enum)(nil)
	}
	r := new(FieldRules_Enum)
	r.Enum = m.Enum.CloneVT()
	return r
}

func (m *FieldRules_Repeated) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Repeated)(nil)
	}
	r := new(FieldRules_Repeated)
	r.Repeated = m.Repeated.CloneVT()
	return r
}

func (m *FieldRules_Map) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Map)(nil)
	}
	r := new(FieldRules_Map)
	r.Map = m.Map.CloneVT()
	return r
}

func (m *FieldRules_Any) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Any)(nil)
	}
	r := new(FieldRules_Any)
	r.Any = m.Any.CloneVT()
	return r
}

func (m *FieldRules_Duration) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Duration)(nil)
	}
	r := new(FieldRules_Duration)
	r.Duration = m.Duration.CloneVT()
	return r
}

func (m *FieldRules_Timestamp) CloneVT() isFieldRules_Type {
	if m == nil {
		return (*FieldRules_Timestamp)(nil)
	}
	r := new(FieldRules_Timestamp)
	r.Timestamp = m.Timestamp.CloneVT()
	return r
}

func (m *FloatRules) CloneVT() *FloatRules {
	if m == nil {
		return (*FloatRules)(nil)
	}
	r := new(FloatRules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Lt; rhs != nil {
		tmpVal := *rhs
		r.Lt = &tmpVal
	}
	if rhs := m.Lte; rhs != nil {
		tmpVal := *rhs
		r.Lte = &tmpVal
	}
	if rhs := m.Gt; rhs != nil {
		tmpVal := *rhs
		r.Gt = &tmpVal
	}
	if rhs := m.Gte; rhs != nil {
		tmpVal := *rhs
		r.Gte = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]float32, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]float32, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *FloatRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *DoubleRules) CloneVT() *DoubleRules {
	if m == nil {
		return (*DoubleRules)(nil)
	}
	r := new(DoubleRules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Lt; rhs != nil {
		tmpVal := *rhs
		r.Lt = &tmpVal
	}
	if rhs := m.Lte; rhs != nil {
		tmpVal := *rhs
		r.Lte = &tmpVal
	}
	if rhs := m.Gt; rhs != nil {
		tmpVal := *rhs
		r.Gt = &tmpVal
	}
	if rhs := m.Gte; rhs != nil {
		tmpVal := *rhs
		r.Gte = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]float64, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]float64, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *DoubleRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *Int32Rules) CloneVT() *Int32Rules {
	if m == nil {
		return (*Int32Rules)(nil)
	}
	r := new(Int32Rules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Lt; rhs != nil {
		tmpVal := *rhs
		r.Lt = &tmpVal
	}
	if rhs := m.Lte; rhs != nil {
		tmpVal := *rhs
		r.Lte = &tmpVal
	}
	if rhs := m.Gt; rhs != nil {
		tmpVal := *rhs
		r.Gt = &tmpVal
	}
	if rhs := m.Gte; rhs != nil {
		tmpVal := *rhs
		r.Gte = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Int32Rules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *Int64Rules) CloneVT() *Int64Rules {
	if m == nil {
		return (*Int64Rules)(nil)
	}
	r := new(Int64Rules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Lt; rhs != nil {
		tmpVal := *rhs
		r.Lt = &tmpVal
	}
	if rhs := m.Lte; rhs != nil {
		tmpVal := *rhs
		r.Lte = &tmpVal
	}
	if rhs := m.Gt; rhs != nil {
		tmpVal := *rhs
		r.Gt = &tmpVal
	}
	if rhs := m.Gte; rhs != nil {
		tmpVal := *rhs
		r.Gte = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Int64Rules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *UInt32Rules) CloneVT() *UInt32Rules {
	if m == nil {
		return (*UInt32Rules)(nil)
	}
	r := new(UInt32Rules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Lt; rhs != nil {
		tmpVal := *rhs
		r.Lt = &tmpVal
	}
	if rhs := m.Lte; rhs != nil {
		tmpVal := *rhs
		r.Lte = &tmpVal
	}
	if rhs := m.Gt; rhs != nil {
		tmpVal := *rhs
		r.Gt = &tmpVal
	}
	if rhs := m.Gte; rhs != nil {
		tmpVal := *rhs
		r.Gte = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *UInt32Rules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *UInt64Rules) CloneVT() *UInt64Rules {
	if m == nil {
		return (*UInt64Rules)(nil)
	}
	r := new(UInt64Rules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Lt; rhs != nil {
		tmpVal := *rhs
		r.Lt = &tmpVal
	}
	if rhs := m.Lte; rhs != nil {
		tmpVal := *rhs
		r.Lte = &tmpVal
	}
	if rhs := m.Gt; rhs != nil {
		tmpVal := *rhs
		r.Gt = &tmpVal
	}
	if rhs := m.Gte; rhs != nil {
		tmpVal := *rhs
		r.Gte = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *UInt64Rules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *SInt32Rules) CloneVT() *SInt32Rules {
	if m == nil {
		return (*SInt32Rules)(nil)
	}
	r := new(SInt32Rules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Lt; rhs != nil {
		tmpVal := *rhs
		r.Lt = &tmpVal
	}
	if rhs := m.Lte; rhs != nil {
		tmpVal := *rhs
		r.Lte = &tmpVal
	}
	if rhs := m.Gt; rhs != nil {
		tmpVal := *rhs
		r.Gt = &tmpVal
	}
	if rhs := m.Gte; rhs != nil {
		tmpVal := *rhs
		r.Gte = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SInt32Rules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *SInt64Rules) CloneVT() *SInt64Rules {
	if m == nil {
		return (*SInt64Rules)(nil)
	}
	r := new(SInt64Rules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Lt; rhs != nil {
		tmpVal := *rhs
		r.Lt = &tmpVal
	}
	if rhs := m.Lte; rhs != nil {
		tmpVal := *rhs
		r.Lte = &tmpVal
	}
	if rhs := m.Gt; rhs != nil {
		tmpVal := *rhs
		r.Gt = &tmpVal
	}
	if rhs := m.Gte; rhs != nil {
		tmpVal := *rhs
		r.Gte = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SInt64Rules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *Fixed32Rules) CloneVT() *Fixed32Rules {
	if m == nil {
		return (*Fixed32Rules)(nil)
	}
	r := new(Fixed32Rules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Lt; rhs != nil {
		tmpVal := *rhs
		r.Lt = &tmpVal
	}
	if rhs := m.Lte; rhs != nil {
		tmpVal := *rhs
		r.Lte = &tmpVal
	}
	if rhs := m.Gt; rhs != nil {
		tmpVal := *rhs
		r.Gt = &tmpVal
	}
	if rhs := m.Gte; rhs != nil {
		tmpVal := *rhs
		r.Gte = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]uint32, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Fixed32Rules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *Fixed64Rules) CloneVT() *Fixed64Rules {
	if m == nil {
		return (*Fixed64Rules)(nil)
	}
	r := new(Fixed64Rules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Lt; rhs != nil {
		tmpVal := *rhs
		r.Lt = &tmpVal
	}
	if rhs := m.Lte; rhs != nil {
		tmpVal := *rhs
		r.Lte = &tmpVal
	}
	if rhs := m.Gt; rhs != nil {
		tmpVal := *rhs
		r.Gt = &tmpVal
	}
	if rhs := m.Gte; rhs != nil {
		tmpVal := *rhs
		r.Gte = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Fixed64Rules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *SFixed32Rules) CloneVT() *SFixed32Rules {
	if m == nil {
		return (*SFixed32Rules)(nil)
	}
	r := new(SFixed32Rules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Lt; rhs != nil {
		tmpVal := *rhs
		r.Lt = &tmpVal
	}
	if rhs := m.Lte; rhs != nil {
		tmpVal := *rhs
		r.Lte = &tmpVal
	}
	if rhs := m.Gt; rhs != nil {
		tmpVal := *rhs
		r.Gt = &tmpVal
	}
	if rhs := m.Gte; rhs != nil {
		tmpVal := *rhs
		r.Gte = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SFixed32Rules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *SFixed64Rules) CloneVT() *SFixed64Rules {
	if m == nil {
		return (*SFixed64Rules)(nil)
	}
	r := new(SFixed64Rules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Lt; rhs != nil {
		tmpVal := *rhs
		r.Lt = &tmpVal
	}
	if rhs := m.Lte; rhs != nil {
		tmpVal := *rhs
		r.Lte = &tmpVal
	}
	if rhs := m.Gt; rhs != nil {
		tmpVal := *rhs
		r.Gt = &tmpVal
	}
	if rhs := m.Gte; rhs != nil {
		tmpVal := *rhs
		r.Gte = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *SFixed64Rules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *BoolRules) CloneVT() *BoolRules {
	if m == nil {
		return (*BoolRules)(nil)
	}
	r := new(BoolRules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *BoolRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *StringRules) CloneVT() *StringRules {
	if m == nil {
		return (*StringRules)(nil)
	}
	r := new(StringRules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.Len; rhs != nil {
		tmpVal := *rhs
		r.Len = &tmpVal
	}
	if rhs := m.MinLen; rhs != nil {
		tmpVal := *rhs
		r.MinLen = &tmpVal
	}
	if rhs := m.MaxLen; rhs != nil {
		tmpVal := *rhs
		r.MaxLen = &tmpVal
	}
	if rhs := m.LenBytes; rhs != nil {
		tmpVal := *rhs
		r.LenBytes = &tmpVal
	}
	if rhs := m.MinBytes; rhs != nil {
		tmpVal := *rhs
		r.MinBytes = &tmpVal
	}
	if rhs := m.MaxBytes; rhs != nil {
		tmpVal := *rhs
		r.MaxBytes = &tmpVal
	}
	if rhs := m.Pattern; rhs != nil {
		tmpVal := *rhs
		r.Pattern = &tmpVal
	}
	if rhs := m.Prefix; rhs != nil {
		tmpVal := *rhs
		r.Prefix = &tmpVal
	}
	if rhs := m.Suffix; rhs != nil {
		tmpVal := *rhs
		r.Suffix = &tmpVal
	}
	if rhs := m.Contains; rhs != nil {
		tmpVal := *rhs
		r.Contains = &tmpVal
	}
	if rhs := m.NotContains; rhs != nil {
		tmpVal := *rhs
		r.NotContains = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if m.WellKnown != nil {
		r.WellKnown = m.WellKnown.(interface {
			CloneVT() isStringRules_WellKnown
		}).CloneVT()
	}
	if rhs := m.Strict; rhs != nil {
		tmpVal := *rhs
		r.Strict = &tmpVal
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *StringRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *StringRules_Email) CloneVT() isStringRules_WellKnown {
	if m == nil {
		return (*StringRules_Email)(nil)
	}
	r := new(StringRules_Email)
	r.Email = m.Email
	return r
}

func (m *StringRules_Hostname) CloneVT() isStringRules_WellKnown {
	if m == nil {
		return (*StringRules_Hostname)(nil)
	}
	r := new(StringRules_Hostname)
	r.Hostname = m.Hostname
	return r
}

func (m *StringRules_Ip) CloneVT() isStringRules_WellKnown {
	if m == nil {
		return (*StringRules_Ip)(nil)
	}
	r := new(StringRules_Ip)
	r.Ip = m.Ip
	return r
}

func (m *StringRules_Ipv4) CloneVT() isStringRules_WellKnown {
	if m == nil {
		return (*StringRules_Ipv4)(nil)
	}
	r := new(StringRules_Ipv4)
	r.Ipv4 = m.Ipv4
	return r
}

func (m *StringRules_Ipv6) CloneVT() isStringRules_WellKnown {
	if m == nil {
		return (*StringRules_Ipv6)(nil)
	}
	r := new(StringRules_Ipv6)
	r.Ipv6 = m.Ipv6
	return r
}

func (m *StringRules_Uri) CloneVT() isStringRules_WellKnown {
	if m == nil {
		return (*StringRules_Uri)(nil)
	}
	r := new(StringRules_Uri)
	r.Uri = m.Uri
	return r
}

func (m *StringRules_UriRef) CloneVT() isStringRules_WellKnown {
	if m == nil {
		return (*StringRules_UriRef)(nil)
	}
	r := new(StringRules_UriRef)
	r.UriRef = m.UriRef
	return r
}

func (m *StringRules_Address) CloneVT() isStringRules_WellKnown {
	if m == nil {
		return (*StringRules_Address)(nil)
	}
	r := new(StringRules_Address)
	r.Address = m.Address
	return r
}

func (m *StringRules_Uuid) CloneVT() isStringRules_WellKnown {
	if m == nil {
		return (*StringRules_Uuid)(nil)
	}
	r := new(StringRules_Uuid)
	r.Uuid = m.Uuid
	return r
}

func (m *StringRules_WellKnownRegex) CloneVT() isStringRules_WellKnown {
	if m == nil {
		return (*StringRules_WellKnownRegex)(nil)
	}
	r := new(StringRules_WellKnownRegex)
	r.WellKnownRegex = m.WellKnownRegex
	return r
}

func (m *BytesRules) CloneVT() *BytesRules {
	if m == nil {
		return (*BytesRules)(nil)
	}
	r := new(BytesRules)
	if rhs := m.Const; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Const = tmpBytes
	}
	if rhs := m.Len; rhs != nil {
		tmpVal := *rhs
		r.Len = &tmpVal
	}
	if rhs := m.MinLen; rhs != nil {
		tmpVal := *rhs
		r.MinLen = &tmpVal
	}
	if rhs := m.MaxLen; rhs != nil {
		tmpVal := *rhs
		r.MaxLen = &tmpVal
	}
	if rhs := m.Pattern; rhs != nil {
		tmpVal := *rhs
		r.Pattern = &tmpVal
	}
	if rhs := m.Prefix; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Prefix = tmpBytes
	}
	if rhs := m.Suffix; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Suffix = tmpBytes
	}
	if rhs := m.Contains; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Contains = tmpBytes
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([][]byte, len(rhs))
		for k, v := range rhs {
			tmpBytes := make([]byte, len(v))
			copy(tmpBytes, v)
			tmpContainer[k] = tmpBytes
		}
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([][]byte, len(rhs))
		for k, v := range rhs {
			tmpBytes := make([]byte, len(v))
			copy(tmpBytes, v)
			tmpContainer[k] = tmpBytes
		}
		r.NotIn = tmpContainer
	}
	if m.WellKnown != nil {
		r.WellKnown = m.WellKnown.(interface{ CloneVT() isBytesRules_WellKnown }).CloneVT()
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *BytesRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *BytesRules_Ip) CloneVT() isBytesRules_WellKnown {
	if m == nil {
		return (*BytesRules_Ip)(nil)
	}
	r := new(BytesRules_Ip)
	r.Ip = m.Ip
	return r
}

func (m *BytesRules_Ipv4) CloneVT() isBytesRules_WellKnown {
	if m == nil {
		return (*BytesRules_Ipv4)(nil)
	}
	r := new(BytesRules_Ipv4)
	r.Ipv4 = m.Ipv4
	return r
}

func (m *BytesRules_Ipv6) CloneVT() isBytesRules_WellKnown {
	if m == nil {
		return (*BytesRules_Ipv6)(nil)
	}
	r := new(BytesRules_Ipv6)
	r.Ipv6 = m.Ipv6
	return r
}

func (m *EnumRules) CloneVT() *EnumRules {
	if m == nil {
		return (*EnumRules)(nil)
	}
	r := new(EnumRules)
	if rhs := m.Const; rhs != nil {
		tmpVal := *rhs
		r.Const = &tmpVal
	}
	if rhs := m.DefinedOnly; rhs != nil {
		tmpVal := *rhs
		r.DefinedOnly = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *EnumRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *MessageRules) CloneVT() *MessageRules {
	if m == nil {
		return (*MessageRules)(nil)
	}
	r := new(MessageRules)
	if rhs := m.Skip; rhs != nil {
		tmpVal := *rhs
		r.Skip = &tmpVal
	}
	if rhs := m.Required; rhs != nil {
		tmpVal := *rhs
		r.Required = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *MessageRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *RepeatedRules) CloneVT() *RepeatedRules {
	if m == nil {
		return (*RepeatedRules)(nil)
	}
	r := new(RepeatedRules)
	r.Items = m.Items.CloneVT()
	if rhs := m.MinItems; rhs != nil {
		tmpVal := *rhs
		r.MinItems = &tmpVal
	}
	if rhs := m.MaxItems; rhs != nil {
		tmpVal := *rhs
		r.MaxItems = &tmpVal
	}
	if rhs := m.Unique; rhs != nil {
		tmpVal := *rhs
		r.Unique = &tmpVal
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *RepeatedRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *MapRules) CloneVT() *MapRules {
	if m == nil {
		return (*MapRules)(nil)
	}
	r := new(MapRules)
	r.Keys = m.Keys.CloneVT()
	r.Values = m.Values.CloneVT()
	if rhs := m.MinPairs; rhs != nil {
		tmpVal := *rhs
		r.MinPairs = &tmpVal
	}
	if rhs := m.MaxPairs; rhs != nil {
		tmpVal := *rhs
		r.MaxPairs = &tmpVal
	}
	if rhs := m.NoSparse; rhs != nil {
		tmpVal := *rhs
		r.NoSparse = &tmpVal
	}
	if rhs := m.IgnoreEmpty; rhs != nil {
		tmpVal := *rhs
		r.IgnoreEmpty = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *MapRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *AnyRules) CloneVT() *AnyRules {
	if m == nil {
		return (*AnyRules)(nil)
	}
	r := new(AnyRules)
	if rhs := m.Required; rhs != nil {
		tmpVal := *rhs
		r.Required = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.NotIn = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *AnyRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *DurationRules) CloneVT() *DurationRules {
	if m == nil {
		return (*DurationRules)(nil)
	}
	r := new(DurationRules)
	r.Const = (*durationpb.Duration)((*durationpb1.Duration)(m.Const).CloneVT())
	r.Lt = (*durationpb.Duration)((*durationpb1.Duration)(m.Lt).CloneVT())
	r.Lte = (*durationpb.Duration)((*durationpb1.Duration)(m.Lte).CloneVT())
	r.Gt = (*durationpb.Duration)((*durationpb1.Duration)(m.Gt).CloneVT())
	r.Gte = (*durationpb.Duration)((*durationpb1.Duration)(m.Gte).CloneVT())
	if rhs := m.Required; rhs != nil {
		tmpVal := *rhs
		r.Required = &tmpVal
	}
	if rhs := m.In; rhs != nil {
		tmpContainer := make([]*durationpb.Duration, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = (*durationpb.Duration)((*durationpb1.Duration)(v).CloneVT())
		}
		r.In = tmpContainer
	}
	if rhs := m.NotIn; rhs != nil {
		tmpContainer := make([]*durationpb.Duration, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = (*durationpb.Duration)((*durationpb1.Duration)(v).CloneVT())
		}
		r.NotIn = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *DurationRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (m *TimestampRules) CloneVT() *TimestampRules {
	if m == nil {
		return (*TimestampRules)(nil)
	}
	r := new(TimestampRules)
	r.Const = (*timestamppb.Timestamp)((*timestamppb1.Timestamp)(m.Const).CloneVT())
	r.Lt = (*timestamppb.Timestamp)((*timestamppb1.Timestamp)(m.Lt).CloneVT())
	r.Lte = (*timestamppb.Timestamp)((*timestamppb1.Timestamp)(m.Lte).CloneVT())
	r.Gt = (*timestamppb.Timestamp)((*timestamppb1.Timestamp)(m.Gt).CloneVT())
	r.Gte = (*timestamppb.Timestamp)((*timestamppb1.Timestamp)(m.Gte).CloneVT())
	r.Within = (*durationpb.Duration)((*durationpb1.Duration)(m.Within).CloneVT())
	if rhs := m.Required; rhs != nil {
		tmpVal := *rhs
		r.Required = &tmpVal
	}
	if rhs := m.LtNow; rhs != nil {
		tmpVal := *rhs
		r.LtNow = &tmpVal
	}
	if rhs := m.GtNow; rhs != nil {
		tmpVal := *rhs
		r.GtNow = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *TimestampRules) CloneMessageVT() proto.Message {
	return m.CloneVT()
}

func (this *FieldRules) EqualVT(that *FieldRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Type == nil && that.Type != nil {
		return false
	} else if this.Type != nil {
		if that.Type == nil {
			return false
		}
		if !this.Type.(interface{ EqualVT(isFieldRules_Type) bool }).EqualVT(that.Type) {
			return false
		}
	}
	if !this.Message.EqualVT(that.Message) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *FieldRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*FieldRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *FieldRules_Float) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Float)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Float, that.Float; p != q {
		if p == nil {
			p = &FloatRules{}
		}
		if q == nil {
			q = &FloatRules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Double) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Double)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Double, that.Double; p != q {
		if p == nil {
			p = &DoubleRules{}
		}
		if q == nil {
			q = &DoubleRules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Int32) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Int32)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Int32, that.Int32; p != q {
		if p == nil {
			p = &Int32Rules{}
		}
		if q == nil {
			q = &Int32Rules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Int64) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Int64)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Int64, that.Int64; p != q {
		if p == nil {
			p = &Int64Rules{}
		}
		if q == nil {
			q = &Int64Rules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Uint32) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Uint32)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Uint32, that.Uint32; p != q {
		if p == nil {
			p = &UInt32Rules{}
		}
		if q == nil {
			q = &UInt32Rules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Uint64) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Uint64)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Uint64, that.Uint64; p != q {
		if p == nil {
			p = &UInt64Rules{}
		}
		if q == nil {
			q = &UInt64Rules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Sint32) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Sint32)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Sint32, that.Sint32; p != q {
		if p == nil {
			p = &SInt32Rules{}
		}
		if q == nil {
			q = &SInt32Rules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Sint64) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Sint64)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Sint64, that.Sint64; p != q {
		if p == nil {
			p = &SInt64Rules{}
		}
		if q == nil {
			q = &SInt64Rules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Fixed32) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Fixed32)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Fixed32, that.Fixed32; p != q {
		if p == nil {
			p = &Fixed32Rules{}
		}
		if q == nil {
			q = &Fixed32Rules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Fixed64) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Fixed64)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Fixed64, that.Fixed64; p != q {
		if p == nil {
			p = &Fixed64Rules{}
		}
		if q == nil {
			q = &Fixed64Rules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Sfixed32) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Sfixed32)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Sfixed32, that.Sfixed32; p != q {
		if p == nil {
			p = &SFixed32Rules{}
		}
		if q == nil {
			q = &SFixed32Rules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Sfixed64) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Sfixed64)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Sfixed64, that.Sfixed64; p != q {
		if p == nil {
			p = &SFixed64Rules{}
		}
		if q == nil {
			q = &SFixed64Rules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Bool) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Bool)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Bool, that.Bool; p != q {
		if p == nil {
			p = &BoolRules{}
		}
		if q == nil {
			q = &BoolRules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_String_) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_String_)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.String_, that.String_; p != q {
		if p == nil {
			p = &StringRules{}
		}
		if q == nil {
			q = &StringRules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Bytes) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Bytes)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Bytes, that.Bytes; p != q {
		if p == nil {
			p = &BytesRules{}
		}
		if q == nil {
			q = &BytesRules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Enum) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Enum)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Enum, that.Enum; p != q {
		if p == nil {
			p = &EnumRules{}
		}
		if q == nil {
			q = &EnumRules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Repeated) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Repeated)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Repeated, that.Repeated; p != q {
		if p == nil {
			p = &RepeatedRules{}
		}
		if q == nil {
			q = &RepeatedRules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Map) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Map)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Map, that.Map; p != q {
		if p == nil {
			p = &MapRules{}
		}
		if q == nil {
			q = &MapRules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Any) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Any)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Any, that.Any; p != q {
		if p == nil {
			p = &AnyRules{}
		}
		if q == nil {
			q = &AnyRules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Duration) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Duration)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Duration, that.Duration; p != q {
		if p == nil {
			p = &DurationRules{}
		}
		if q == nil {
			q = &DurationRules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FieldRules_Timestamp) EqualVT(thatIface isFieldRules_Type) bool {
	that, ok := thatIface.(*FieldRules_Timestamp)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.Timestamp, that.Timestamp; p != q {
		if p == nil {
			p = &TimestampRules{}
		}
		if q == nil {
			q = &TimestampRules{}
		}
		if !p.EqualVT(q) {
			return false
		}
	}
	return true
}

func (this *FloatRules) EqualVT(that *FloatRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lt, that.Lt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lte, that.Lte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gt, that.Gt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gte, that.Gte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *FloatRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*FloatRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *DoubleRules) EqualVT(that *DoubleRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lt, that.Lt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lte, that.Lte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gt, that.Gt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gte, that.Gte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *DoubleRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*DoubleRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Int32Rules) EqualVT(that *Int32Rules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lt, that.Lt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lte, that.Lte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gt, that.Gt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gte, that.Gte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Int32Rules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*Int32Rules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Int64Rules) EqualVT(that *Int64Rules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lt, that.Lt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lte, that.Lte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gt, that.Gt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gte, that.Gte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Int64Rules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*Int64Rules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *UInt32Rules) EqualVT(that *UInt32Rules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lt, that.Lt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lte, that.Lte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gt, that.Gt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gte, that.Gte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *UInt32Rules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*UInt32Rules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *UInt64Rules) EqualVT(that *UInt64Rules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lt, that.Lt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lte, that.Lte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gt, that.Gt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gte, that.Gte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *UInt64Rules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*UInt64Rules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SInt32Rules) EqualVT(that *SInt32Rules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lt, that.Lt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lte, that.Lte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gt, that.Gt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gte, that.Gte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SInt32Rules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*SInt32Rules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SInt64Rules) EqualVT(that *SInt64Rules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lt, that.Lt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lte, that.Lte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gt, that.Gt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gte, that.Gte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SInt64Rules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*SInt64Rules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Fixed32Rules) EqualVT(that *Fixed32Rules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lt, that.Lt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lte, that.Lte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gt, that.Gt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gte, that.Gte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Fixed32Rules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*Fixed32Rules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Fixed64Rules) EqualVT(that *Fixed64Rules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lt, that.Lt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lte, that.Lte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gt, that.Gt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gte, that.Gte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Fixed64Rules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*Fixed64Rules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SFixed32Rules) EqualVT(that *SFixed32Rules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lt, that.Lt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lte, that.Lte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gt, that.Gt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gte, that.Gte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SFixed32Rules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*SFixed32Rules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *SFixed64Rules) EqualVT(that *SFixed64Rules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lt, that.Lt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lte, that.Lte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gt, that.Gt; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Gte, that.Gte; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *SFixed64Rules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*SFixed64Rules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *BoolRules) EqualVT(that *BoolRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *BoolRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*BoolRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *StringRules) EqualVT(that *StringRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.WellKnown == nil && that.WellKnown != nil {
		return false
	} else if this.WellKnown != nil {
		if that.WellKnown == nil {
			return false
		}
		if !this.WellKnown.(interface {
			EqualVT(isStringRules_WellKnown) bool
		}).EqualVT(that.WellKnown) {
			return false
		}
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MinLen, that.MinLen; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MaxLen, that.MaxLen; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MinBytes, that.MinBytes; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MaxBytes, that.MaxBytes; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Pattern, that.Pattern; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Prefix, that.Prefix; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Suffix, that.Suffix; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Contains, that.Contains; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.Len, that.Len; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.LenBytes, that.LenBytes; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.NotContains, that.NotContains; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Strict, that.Strict; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *StringRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*StringRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *StringRules_Email) EqualVT(thatIface isStringRules_WellKnown) bool {
	that, ok := thatIface.(*StringRules_Email)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.Email != that.Email {
		return false
	}
	return true
}

func (this *StringRules_Hostname) EqualVT(thatIface isStringRules_WellKnown) bool {
	that, ok := thatIface.(*StringRules_Hostname)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.Hostname != that.Hostname {
		return false
	}
	return true
}

func (this *StringRules_Ip) EqualVT(thatIface isStringRules_WellKnown) bool {
	that, ok := thatIface.(*StringRules_Ip)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.Ip != that.Ip {
		return false
	}
	return true
}

func (this *StringRules_Ipv4) EqualVT(thatIface isStringRules_WellKnown) bool {
	that, ok := thatIface.(*StringRules_Ipv4)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.Ipv4 != that.Ipv4 {
		return false
	}
	return true
}

func (this *StringRules_Ipv6) EqualVT(thatIface isStringRules_WellKnown) bool {
	that, ok := thatIface.(*StringRules_Ipv6)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.Ipv6 != that.Ipv6 {
		return false
	}
	return true
}

func (this *StringRules_Uri) EqualVT(thatIface isStringRules_WellKnown) bool {
	that, ok := thatIface.(*StringRules_Uri)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.Uri != that.Uri {
		return false
	}
	return true
}

func (this *StringRules_UriRef) EqualVT(thatIface isStringRules_WellKnown) bool {
	that, ok := thatIface.(*StringRules_UriRef)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.UriRef != that.UriRef {
		return false
	}
	return true
}

func (this *StringRules_Address) EqualVT(thatIface isStringRules_WellKnown) bool {
	that, ok := thatIface.(*StringRules_Address)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.Address != that.Address {
		return false
	}
	return true
}

func (this *StringRules_Uuid) EqualVT(thatIface isStringRules_WellKnown) bool {
	that, ok := thatIface.(*StringRules_Uuid)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.Uuid != that.Uuid {
		return false
	}
	return true
}

func (this *StringRules_WellKnownRegex) EqualVT(thatIface isStringRules_WellKnown) bool {
	that, ok := thatIface.(*StringRules_WellKnownRegex)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.WellKnownRegex != that.WellKnownRegex {
		return false
	}
	return true
}

func (this *BytesRules) EqualVT(that *BytesRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.WellKnown == nil && that.WellKnown != nil {
		return false
	} else if this.WellKnown != nil {
		if that.WellKnown == nil {
			return false
		}
		if !this.WellKnown.(interface {
			EqualVT(isBytesRules_WellKnown) bool
		}).EqualVT(that.WellKnown) {
			return false
		}
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && q == nil) || string(p) != string(q) {
		return false
	}
	if p, q := this.MinLen, that.MinLen; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MaxLen, that.MaxLen; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Pattern, that.Pattern; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Prefix, that.Prefix; (p == nil && q != nil) || (p != nil && q == nil) || string(p) != string(q) {
		return false
	}
	if p, q := this.Suffix, that.Suffix; (p == nil && q != nil) || (p != nil && q == nil) || string(p) != string(q) {
		return false
	}
	if p, q := this.Contains, that.Contains; (p == nil && q != nil) || (p != nil && q == nil) || string(p) != string(q) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if string(vx) != string(vy) {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if string(vx) != string(vy) {
			return false
		}
	}
	if p, q := this.Len, that.Len; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *BytesRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*BytesRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *BytesRules_Ip) EqualVT(thatIface isBytesRules_WellKnown) bool {
	that, ok := thatIface.(*BytesRules_Ip)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.Ip != that.Ip {
		return false
	}
	return true
}

func (this *BytesRules_Ipv4) EqualVT(thatIface isBytesRules_WellKnown) bool {
	that, ok := thatIface.(*BytesRules_Ipv4)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.Ipv4 != that.Ipv4 {
		return false
	}
	return true
}

func (this *BytesRules_Ipv6) EqualVT(thatIface isBytesRules_WellKnown) bool {
	that, ok := thatIface.(*BytesRules_Ipv6)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.Ipv6 != that.Ipv6 {
		return false
	}
	return true
}

func (this *EnumRules) EqualVT(that *EnumRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Const, that.Const; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefinedOnly, that.DefinedOnly; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnumRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*EnumRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *MessageRules) EqualVT(that *MessageRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Skip, that.Skip; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Required, that.Required; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *MessageRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*MessageRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *RepeatedRules) EqualVT(that *RepeatedRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.MinItems, that.MinItems; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MaxItems, that.MaxItems; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Unique, that.Unique; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Items.EqualVT(that.Items) {
		return false
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *RepeatedRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*RepeatedRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *MapRules) EqualVT(that *MapRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.MinPairs, that.MinPairs; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MaxPairs, that.MaxPairs; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.NoSparse, that.NoSparse; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Keys.EqualVT(that.Keys) {
		return false
	}
	if !this.Values.EqualVT(that.Values) {
		return false
	}
	if p, q := this.IgnoreEmpty, that.IgnoreEmpty; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *MapRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*MapRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *AnyRules) EqualVT(that *AnyRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Required, that.Required; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if vx != vy {
			return false
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *AnyRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*AnyRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *DurationRules) EqualVT(that *DurationRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Required, that.Required; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !(*durationpb1.Duration)(this.Const).EqualVT((*durationpb1.Duration)(that.Const)) {
		return false
	}
	if !(*durationpb1.Duration)(this.Lt).EqualVT((*durationpb1.Duration)(that.Lt)) {
		return false
	}
	if !(*durationpb1.Duration)(this.Lte).EqualVT((*durationpb1.Duration)(that.Lte)) {
		return false
	}
	if !(*durationpb1.Duration)(this.Gt).EqualVT((*durationpb1.Duration)(that.Gt)) {
		return false
	}
	if !(*durationpb1.Duration)(this.Gte).EqualVT((*durationpb1.Duration)(that.Gte)) {
		return false
	}
	if len(this.In) != len(that.In) {
		return false
	}
	for i, vx := range this.In {
		vy := that.In[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &durationpb.Duration{}
			}
			if q == nil {
				q = &durationpb.Duration{}
			}
			if !(*durationpb1.Duration)(p).EqualVT((*durationpb1.Duration)(q)) {
				return false
			}
		}
	}
	if len(this.NotIn) != len(that.NotIn) {
		return false
	}
	for i, vx := range this.NotIn {
		vy := that.NotIn[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &durationpb.Duration{}
			}
			if q == nil {
				q = &durationpb.Duration{}
			}
			if !(*durationpb1.Duration)(p).EqualVT((*durationpb1.Duration)(q)) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *DurationRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*DurationRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *TimestampRules) EqualVT(that *TimestampRules) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Required, that.Required; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !(*timestamppb1.Timestamp)(this.Const).EqualVT((*timestamppb1.Timestamp)(that.Const)) {
		return false
	}
	if !(*timestamppb1.Timestamp)(this.Lt).EqualVT((*timestamppb1.Timestamp)(that.Lt)) {
		return false
	}
	if !(*timestamppb1.Timestamp)(this.Lte).EqualVT((*timestamppb1.Timestamp)(that.Lte)) {
		return false
	}
	if !(*timestamppb1.Timestamp)(this.Gt).EqualVT((*timestamppb1.Timestamp)(that.Gt)) {
		return false
	}
	if !(*timestamppb1.Timestamp)(this.Gte).EqualVT((*timestamppb1.Timestamp)(that.Gte)) {
		return false
	}
	if p, q := this.LtNow, that.LtNow; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.GtNow, that.GtNow; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !(*durationpb1.Duration)(this.Within).EqualVT((*durationpb1.Duration)(that.Within)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *TimestampRules) EqualMessageVT(thatMsg proto.Message) bool {
	that, ok := thatMsg.(*TimestampRules)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (m *FieldRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if vtmsg, ok := m.Type.(interface {
		MarshalToSizedBufferVT([]byte) (int, error)
	}); ok {
		size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if m.Message != nil {
		size, err := m.Message.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}

func (m *FieldRules_Float) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Float) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Float != nil {
		size, err := m.Float.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Double) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Double) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Double != nil {
		size, err := m.Double.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Int32) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Int32) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Int32 != nil {
		size, err := m.Int32.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Int64) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Int64) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Int64 != nil {
		size, err := m.Int64.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Uint32) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Uint32) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Uint32 != nil {
		size, err := m.Uint32.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x2a
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Uint64) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Uint64) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Uint64 != nil {
		size, err := m.Uint64.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x32
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Sint32) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Sint32) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sint32 != nil {
		size, err := m.Sint32.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Sint64) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Sint64) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sint64 != nil {
		size, err := m.Sint64.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Fixed32) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Fixed32) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Fixed32 != nil {
		size, err := m.Fixed32.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x4a
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Fixed64) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Fixed64) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Fixed64 != nil {
		size, err := m.Fixed64.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x52
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Sfixed32) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Sfixed32) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sfixed32 != nil {
		size, err := m.Sfixed32.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x5a
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Sfixed64) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Sfixed64) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sfixed64 != nil {
		size, err := m.Sfixed64.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x62
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Bool) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Bool) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bool != nil {
		size, err := m.Bool.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x6a
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_String_) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_String_) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.String_ != nil {
		size, err := m.String_.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x72
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Bytes) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Bytes) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bytes != nil {
		size, err := m.Bytes.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x7a
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Enum) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Enum) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Enum != nil {
		size, err := m.Enum.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Repeated) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Repeated) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Repeated != nil {
		size, err := m.Repeated.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Map) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Map) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Map != nil {
		size, err := m.Map.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Any) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Any) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Any != nil {
		size, err := m.Any.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Duration) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Duration) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Duration != nil {
		size, err := m.Duration.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *FieldRules_Timestamp) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FieldRules_Timestamp) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Timestamp != nil {
		size, err := m.Timestamp.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	} else {
		i = protohelpers.EncodeVarint(dAtA, i, 0)
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *FloatRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *FloatRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float32bits(float32(m.NotIn[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f1))
			i--
			dAtA[i] = 0x3d
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			f2 := math.Float32bits(float32(m.In[iNdEx]))
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(f2))
			i--
			dAtA[i] = 0x35
		}
	}
	if m.Gte != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Gte))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Gt != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Gt))))
		i--
		dAtA[i] = 0x25
	}
	if m.Lte != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Lte))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Lt != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Lt))))
		i--
		dAtA[i] = 0x15
	}
	if m.Const != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(*m.Const))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *DoubleRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *DoubleRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float64bits(float64(m.NotIn[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f1))
			i--
			dAtA[i] = 0x39
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			f2 := math.Float64bits(float64(m.In[iNdEx]))
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(f2))
			i--
			dAtA[i] = 0x31
		}
	}
	if m.Gte != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Gte))))
		i--
		dAtA[i] = 0x29
	}
	if m.Gt != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Gt))))
		i--
		dAtA[i] = 0x21
	}
	if m.Lte != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Lte))))
		i--
		dAtA[i] = 0x19
	}
	if m.Lt != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Lt))))
		i--
		dAtA[i] = 0x11
	}
	if m.Const != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.Const))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Int32Rules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int32Rules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Int32Rules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			i = protohelpers.EncodeVarint(dAtA, i, uint64(m.NotIn[iNdEx]))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			i = protohelpers.EncodeVarint(dAtA, i, uint64(m.In[iNdEx]))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.Gte != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Gte))
		i--
		dAtA[i] = 0x28
	}
	if m.Gt != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Gt))
		i--
		dAtA[i] = 0x20
	}
	if m.Lte != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Lte))
		i--
		dAtA[i] = 0x18
	}
	if m.Lt != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Lt))
		i--
		dAtA[i] = 0x10
	}
	if m.Const != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Const))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Int64Rules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int64Rules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Int64Rules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			i = protohelpers.EncodeVarint(dAtA, i, uint64(m.NotIn[iNdEx]))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			i = protohelpers.EncodeVarint(dAtA, i, uint64(m.In[iNdEx]))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.Gte != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Gte))
		i--
		dAtA[i] = 0x28
	}
	if m.Gt != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Gt))
		i--
		dAtA[i] = 0x20
	}
	if m.Lte != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Lte))
		i--
		dAtA[i] = 0x18
	}
	if m.Lt != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Lt))
		i--
		dAtA[i] = 0x10
	}
	if m.Const != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Const))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UInt32Rules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UInt32Rules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *UInt32Rules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			i = protohelpers.EncodeVarint(dAtA, i, uint64(m.NotIn[iNdEx]))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			i = protohelpers.EncodeVarint(dAtA, i, uint64(m.In[iNdEx]))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.Gte != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Gte))
		i--
		dAtA[i] = 0x28
	}
	if m.Gt != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Gt))
		i--
		dAtA[i] = 0x20
	}
	if m.Lte != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Lte))
		i--
		dAtA[i] = 0x18
	}
	if m.Lt != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Lt))
		i--
		dAtA[i] = 0x10
	}
	if m.Const != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Const))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UInt64Rules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UInt64Rules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *UInt64Rules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			i = protohelpers.EncodeVarint(dAtA, i, uint64(m.NotIn[iNdEx]))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			i = protohelpers.EncodeVarint(dAtA, i, uint64(m.In[iNdEx]))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.Gte != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Gte))
		i--
		dAtA[i] = 0x28
	}
	if m.Gt != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Gt))
		i--
		dAtA[i] = 0x20
	}
	if m.Lte != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Lte))
		i--
		dAtA[i] = 0x18
	}
	if m.Lt != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Lt))
		i--
		dAtA[i] = 0x10
	}
	if m.Const != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Const))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SInt32Rules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SInt32Rules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SInt32Rules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			x1 := (uint32(m.NotIn[iNdEx]) << 1) ^ uint32((m.NotIn[iNdEx] >> 31))
			i = protohelpers.EncodeVarint(dAtA, i, uint64(x1))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			x2 := (uint32(m.In[iNdEx]) << 1) ^ uint32((m.In[iNdEx] >> 31))
			i = protohelpers.EncodeVarint(dAtA, i, uint64(x2))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.Gte != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64((uint32(*m.Gte)<<1)^uint32((*m.Gte>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.Gt != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64((uint32(*m.Gt)<<1)^uint32((*m.Gt>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Lte != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64((uint32(*m.Lte)<<1)^uint32((*m.Lte>>31))))
		i--
		dAtA[i] = 0x18
	}
	if m.Lt != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64((uint32(*m.Lt)<<1)^uint32((*m.Lt>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Const != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64((uint32(*m.Const)<<1)^uint32((*m.Const>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SInt64Rules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SInt64Rules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SInt64Rules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			x1 := (uint64(m.NotIn[iNdEx]) << 1) ^ uint64((m.NotIn[iNdEx] >> 63))
			i = protohelpers.EncodeVarint(dAtA, i, uint64(x1))
			i--
			dAtA[i] = 0x38
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			x2 := (uint64(m.In[iNdEx]) << 1) ^ uint64((m.In[iNdEx] >> 63))
			i = protohelpers.EncodeVarint(dAtA, i, uint64(x2))
			i--
			dAtA[i] = 0x30
		}
	}
	if m.Gte != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64((uint64(*m.Gte)<<1)^uint64((*m.Gte>>63))))
		i--
		dAtA[i] = 0x28
	}
	if m.Gt != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64((uint64(*m.Gt)<<1)^uint64((*m.Gt>>63))))
		i--
		dAtA[i] = 0x20
	}
	if m.Lte != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64((uint64(*m.Lte)<<1)^uint64((*m.Lte>>63))))
		i--
		dAtA[i] = 0x18
	}
	if m.Lt != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64((uint64(*m.Lt)<<1)^uint64((*m.Lt>>63))))
		i--
		dAtA[i] = 0x10
	}
	if m.Const != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64((uint64(*m.Const)<<1)^uint64((*m.Const>>63))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Fixed32Rules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fixed32Rules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Fixed32Rules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NotIn[iNdEx]))
			i--
			dAtA[i] = 0x3d
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.In[iNdEx]))
			i--
			dAtA[i] = 0x35
		}
	}
	if m.Gte != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Gte))
		i--
		dAtA[i] = 0x2d
	}
	if m.Gt != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Gt))
		i--
		dAtA[i] = 0x25
	}
	if m.Lte != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Lte))
		i--
		dAtA[i] = 0x1d
	}
	if m.Lt != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Lt))
		i--
		dAtA[i] = 0x15
	}
	if m.Const != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Const))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *Fixed64Rules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fixed64Rules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Fixed64Rules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.NotIn[iNdEx]))
			i--
			dAtA[i] = 0x39
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.In[iNdEx]))
			i--
			dAtA[i] = 0x31
		}
	}
	if m.Gte != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.Gte))
		i--
		dAtA[i] = 0x29
	}
	if m.Gt != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.Gt))
		i--
		dAtA[i] = 0x21
	}
	if m.Lte != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.Lte))
		i--
		dAtA[i] = 0x19
	}
	if m.Lt != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.Lt))
		i--
		dAtA[i] = 0x11
	}
	if m.Const != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.Const))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *SFixed32Rules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SFixed32Rules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SFixed32Rules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.NotIn[iNdEx]))
			i--
			dAtA[i] = 0x3d
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			i -= 4
			binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.In[iNdEx]))
			i--
			dAtA[i] = 0x35
		}
	}
	if m.Gte != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Gte))
		i--
		dAtA[i] = 0x2d
	}
	if m.Gt != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Gt))
		i--
		dAtA[i] = 0x25
	}
	if m.Lte != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Lte))
		i--
		dAtA[i] = 0x1d
	}
	if m.Lt != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Lt))
		i--
		dAtA[i] = 0x15
	}
	if m.Const != nil {
		i -= 4
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(*m.Const))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *SFixed64Rules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SFixed64Rules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *SFixed64Rules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.NotIn[iNdEx]))
			i--
			dAtA[i] = 0x39
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			i -= 8
			binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.In[iNdEx]))
			i--
			dAtA[i] = 0x31
		}
	}
	if m.Gte != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.Gte))
		i--
		dAtA[i] = 0x29
	}
	if m.Gt != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.Gt))
		i--
		dAtA[i] = 0x21
	}
	if m.Lte != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.Lte))
		i--
		dAtA[i] = 0x19
	}
	if m.Lt != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.Lt))
		i--
		dAtA[i] = 0x11
	}
	if m.Const != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(*m.Const))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *BoolRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoolRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *BoolRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Const != nil {
		i--
		if *m.Const {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StringRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StringRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if vtmsg, ok := m.WellKnown.(interface {
		MarshalToSizedBufferVT([]byte) (int, error)
	}); ok {
		size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.Strict != nil {
		i--
		if *m.Strict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.NotContains != nil {
		i -= len(*m.NotContains)
		copy(dAtA[i:], *m.NotContains)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(*m.NotContains)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.LenBytes != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.LenBytes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Len != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Len))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NotIn[iNdEx])
			copy(dAtA[i:], m.NotIn[iNdEx])
			i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.NotIn[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.In[iNdEx])
			copy(dAtA[i:], m.In[iNdEx])
			i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.In[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.Contains != nil {
		i -= len(*m.Contains)
		copy(dAtA[i:], *m.Contains)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(*m.Contains)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Suffix != nil {
		i -= len(*m.Suffix)
		copy(dAtA[i:], *m.Suffix)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(*m.Suffix)))
		i--
		dAtA[i] = 0x42
	}
	if m.Prefix != nil {
		i -= len(*m.Prefix)
		copy(dAtA[i:], *m.Prefix)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(*m.Prefix)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Pattern != nil {
		i -= len(*m.Pattern)
		copy(dAtA[i:], *m.Pattern)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(*m.Pattern)))
		i--
		dAtA[i] = 0x32
	}
	if m.MaxBytes != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.MaxBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.MinBytes != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.MinBytes))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxLen != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.MaxLen))
		i--
		dAtA[i] = 0x18
	}
	if m.MinLen != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.MinLen))
		i--
		dAtA[i] = 0x10
	}
	if m.Const != nil {
		i -= len(*m.Const)
		copy(dAtA[i:], *m.Const)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(*m.Const)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StringRules_Email) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StringRules_Email) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Email {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x60
	return len(dAtA) - i, nil
}
func (m *StringRules_Hostname) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StringRules_Hostname) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Hostname {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x68
	return len(dAtA) - i, nil
}
func (m *StringRules_Ip) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StringRules_Ip) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Ip {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x70
	return len(dAtA) - i, nil
}
func (m *StringRules_Ipv4) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StringRules_Ipv4) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Ipv4 {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x78
	return len(dAtA) - i, nil
}
func (m *StringRules_Ipv6) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StringRules_Ipv6) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Ipv6 {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	return len(dAtA) - i, nil
}
func (m *StringRules_Uri) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StringRules_Uri) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Uri {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	return len(dAtA) - i, nil
}
func (m *StringRules_UriRef) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StringRules_UriRef) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.UriRef {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x90
	return len(dAtA) - i, nil
}
func (m *StringRules_Address) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StringRules_Address) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Address {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa8
	return len(dAtA) - i, nil
}
func (m *StringRules_Uuid) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StringRules_Uuid) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Uuid {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb0
	return len(dAtA) - i, nil
}
func (m *StringRules_WellKnownRegex) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StringRules_WellKnownRegex) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = protohelpers.EncodeVarint(dAtA, i, uint64(m.WellKnownRegex))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc0
	return len(dAtA) - i, nil
}
func (m *BytesRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BytesRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *BytesRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if vtmsg, ok := m.WellKnown.(interface {
		MarshalToSizedBufferVT([]byte) (int, error)
	}); ok {
		size, err := vtmsg.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.Len != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Len))
		i--
		dAtA[i] = 0x68
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NotIn[iNdEx])
			copy(dAtA[i:], m.NotIn[iNdEx])
			i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.NotIn[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.In[iNdEx])
			copy(dAtA[i:], m.In[iNdEx])
			i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.In[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Contains != nil {
		i -= len(m.Contains)
		copy(dAtA[i:], m.Contains)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.Contains)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Suffix != nil {
		i -= len(m.Suffix)
		copy(dAtA[i:], m.Suffix)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.Suffix)))
		i--
		dAtA[i] = 0x32
	}
	if m.Prefix != nil {
		i -= len(m.Prefix)
		copy(dAtA[i:], m.Prefix)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.Prefix)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Pattern != nil {
		i -= len(*m.Pattern)
		copy(dAtA[i:], *m.Pattern)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(*m.Pattern)))
		i--
		dAtA[i] = 0x22
	}
	if m.MaxLen != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.MaxLen))
		i--
		dAtA[i] = 0x18
	}
	if m.MinLen != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.MinLen))
		i--
		dAtA[i] = 0x10
	}
	if m.Const != nil {
		i -= len(m.Const)
		copy(dAtA[i:], m.Const)
		i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.Const)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BytesRules_Ip) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *BytesRules_Ip) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Ip {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x50
	return len(dAtA) - i, nil
}
func (m *BytesRules_Ipv4) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *BytesRules_Ipv4) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Ipv4 {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x58
	return len(dAtA) - i, nil
}
func (m *BytesRules_Ipv6) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *BytesRules_Ipv6) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Ipv6 {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x60
	return len(dAtA) - i, nil
}
func (m *EnumRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnumRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnumRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			i = protohelpers.EncodeVarint(dAtA, i, uint64(m.NotIn[iNdEx]))
			i--
			dAtA[i] = 0x20
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			i = protohelpers.EncodeVarint(dAtA, i, uint64(m.In[iNdEx]))
			i--
			dAtA[i] = 0x18
		}
	}
	if m.DefinedOnly != nil {
		i--
		if *m.DefinedOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Const != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.Const))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessageRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *MessageRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Required != nil {
		i--
		if *m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Skip != nil {
		i--
		if *m.Skip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RepeatedRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepeatedRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *RepeatedRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Items != nil {
		size, err := m.Items.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if m.Unique != nil {
		i--
		if *m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.MaxItems != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.MaxItems))
		i--
		dAtA[i] = 0x10
	}
	if m.MinItems != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.MinItems))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MapRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *MapRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.IgnoreEmpty != nil {
		i--
		if *m.IgnoreEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Values != nil {
		size, err := m.Values.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x2a
	}
	if m.Keys != nil {
		size, err := m.Keys.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if m.NoSparse != nil {
		i--
		if *m.NoSparse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.MaxPairs != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.MaxPairs))
		i--
		dAtA[i] = 0x10
	}
	if m.MinPairs != nil {
		i = protohelpers.EncodeVarint(dAtA, i, uint64(*m.MinPairs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AnyRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnyRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *AnyRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NotIn[iNdEx])
			copy(dAtA[i:], m.NotIn[iNdEx])
			i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.NotIn[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.In[iNdEx])
			copy(dAtA[i:], m.In[iNdEx])
			i = protohelpers.EncodeVarint(dAtA, i, uint64(len(m.In[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Required != nil {
		i--
		if *m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DurationRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DurationRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *DurationRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.NotIn) > 0 {
		for iNdEx := len(m.NotIn) - 1; iNdEx >= 0; iNdEx-- {
			size, err := (*durationpb1.Duration)(m.NotIn[iNdEx]).MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.In) > 0 {
		for iNdEx := len(m.In) - 1; iNdEx >= 0; iNdEx-- {
			size, err := (*durationpb1.Duration)(m.In[iNdEx]).MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Gte != nil {
		size, err := (*durationpb1.Duration)(m.Gte).MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x32
	}
	if m.Gt != nil {
		size, err := (*durationpb1.Duration)(m.Gt).MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x2a
	}
	if m.Lte != nil {
		size, err := (*durationpb1.Duration)(m.Lte).MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if m.Lt != nil {
		size, err := (*durationpb1.Duration)(m.Lt).MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Const != nil {
		size, err := (*durationpb1.Duration)(m.Const).MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Required != nil {
		i--
		if *m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TimestampRules) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimestampRules) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *TimestampRules) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Within != nil {
		size, err := (*durationpb1.Duration)(m.Within).MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x4a
	}
	if m.GtNow != nil {
		i--
		if *m.GtNow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.LtNow != nil {
		i--
		if *m.LtNow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Gte != nil {
		size, err := (*timestamppb1.Timestamp)(m.Gte).MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x32
	}
	if m.Gt != nil {
		size, err := (*timestamppb1.Timestamp)(m.Gt).MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x2a
	}
	if m.Lte != nil {
		size, err := (*timestamppb1.Timestamp)(m.Lte).MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if m.Lt != nil {
		size, err := (*timestamppb1.Timestamp)(m.Lt).MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Const != nil {
		size, err := (*timestamppb1.Timestamp)(m.Const).MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protohelpers.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Required != nil {
		i--
		if *m.Required {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FieldRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if vtmsg, ok := m.Type.(interface{ SizeVT() int }); ok {
		n += vtmsg.SizeVT()
	}
	if m.Message != nil {
		l = m.Message.SizeVT()
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *FieldRules_Float) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Float != nil {
		l = m.Float.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Double) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Double != nil {
		l = m.Double.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Int32) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Int32 != nil {
		l = m.Int32.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Int64) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Int64 != nil {
		l = m.Int64.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Uint32) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uint32 != nil {
		l = m.Uint32.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Uint64) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uint64 != nil {
		l = m.Uint64.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Sint32) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sint32 != nil {
		l = m.Sint32.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Sint64) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sint64 != nil {
		l = m.Sint64.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Fixed32) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fixed32 != nil {
		l = m.Fixed32.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Fixed64) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fixed64 != nil {
		l = m.Fixed64.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Sfixed32) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sfixed32 != nil {
		l = m.Sfixed32.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Sfixed64) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sfixed64 != nil {
		l = m.Sfixed64.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Bool) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bool != nil {
		l = m.Bool.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_String_) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.String_ != nil {
		l = m.String_.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Bytes) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bytes != nil {
		l = m.Bytes.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 2
	}
	return n
}
func (m *FieldRules_Enum) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enum != nil {
		l = m.Enum.SizeVT()
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 3
	}
	return n
}
func (m *FieldRules_Repeated) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repeated != nil {
		l = m.Repeated.SizeVT()
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 3
	}
	return n
}
func (m *FieldRules_Map) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Map != nil {
		l = m.Map.SizeVT()
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 3
	}
	return n
}
func (m *FieldRules_Any) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Any != nil {
		l = m.Any.SizeVT()
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 3
	}
	return n
}
func (m *FieldRules_Duration) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Duration != nil {
		l = m.Duration.SizeVT()
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 3
	}
	return n
}
func (m *FieldRules_Timestamp) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.SizeVT()
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	} else {
		n += 3
	}
	return n
}
func (m *FloatRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 5
	}
	if m.Lt != nil {
		n += 5
	}
	if m.Lte != nil {
		n += 5
	}
	if m.Gt != nil {
		n += 5
	}
	if m.Gte != nil {
		n += 5
	}
	if len(m.In) > 0 {
		n += 5 * len(m.In)
	}
	if len(m.NotIn) > 0 {
		n += 5 * len(m.NotIn)
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *DoubleRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 9
	}
	if m.Lt != nil {
		n += 9
	}
	if m.Lte != nil {
		n += 9
	}
	if m.Gt != nil {
		n += 9
	}
	if m.Gte != nil {
		n += 9
	}
	if len(m.In) > 0 {
		n += 9 * len(m.In)
	}
	if len(m.NotIn) > 0 {
		n += 9 * len(m.NotIn)
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *Int32Rules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Const))
	}
	if m.Lt != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Lt))
	}
	if m.Lte != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Lte))
	}
	if m.Gt != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Gt))
	}
	if m.Gte != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Gte))
	}
	if len(m.In) > 0 {
		for _, e := range m.In {
			n += 1 + protohelpers.SizeOfVarint(uint64(e))
		}
	}
	if len(m.NotIn) > 0 {
		for _, e := range m.NotIn {
			n += 1 + protohelpers.SizeOfVarint(uint64(e))
		}
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *Int64Rules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Const))
	}
	if m.Lt != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Lt))
	}
	if m.Lte != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Lte))
	}
	if m.Gt != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Gt))
	}
	if m.Gte != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Gte))
	}
	if len(m.In) > 0 {
		for _, e := range m.In {
			n += 1 + protohelpers.SizeOfVarint(uint64(e))
		}
	}
	if len(m.NotIn) > 0 {
		for _, e := range m.NotIn {
			n += 1 + protohelpers.SizeOfVarint(uint64(e))
		}
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *UInt32Rules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Const))
	}
	if m.Lt != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Lt))
	}
	if m.Lte != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Lte))
	}
	if m.Gt != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Gt))
	}
	if m.Gte != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Gte))
	}
	if len(m.In) > 0 {
		for _, e := range m.In {
			n += 1 + protohelpers.SizeOfVarint(uint64(e))
		}
	}
	if len(m.NotIn) > 0 {
		for _, e := range m.NotIn {
			n += 1 + protohelpers.SizeOfVarint(uint64(e))
		}
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *UInt64Rules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Const))
	}
	if m.Lt != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Lt))
	}
	if m.Lte != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Lte))
	}
	if m.Gt != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Gt))
	}
	if m.Gte != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Gte))
	}
	if len(m.In) > 0 {
		for _, e := range m.In {
			n += 1 + protohelpers.SizeOfVarint(uint64(e))
		}
	}
	if len(m.NotIn) > 0 {
		for _, e := range m.NotIn {
			n += 1 + protohelpers.SizeOfVarint(uint64(e))
		}
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *SInt32Rules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 1 + protohelpers.SizeOfZigzag(uint64(*m.Const))
	}
	if m.Lt != nil {
		n += 1 + protohelpers.SizeOfZigzag(uint64(*m.Lt))
	}
	if m.Lte != nil {
		n += 1 + protohelpers.SizeOfZigzag(uint64(*m.Lte))
	}
	if m.Gt != nil {
		n += 1 + protohelpers.SizeOfZigzag(uint64(*m.Gt))
	}
	if m.Gte != nil {
		n += 1 + protohelpers.SizeOfZigzag(uint64(*m.Gte))
	}
	if len(m.In) > 0 {
		for _, e := range m.In {
			n += 1 + protohelpers.SizeOfZigzag(uint64(e))
		}
	}
	if len(m.NotIn) > 0 {
		for _, e := range m.NotIn {
			n += 1 + protohelpers.SizeOfZigzag(uint64(e))
		}
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *SInt64Rules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 1 + protohelpers.SizeOfZigzag(uint64(*m.Const))
	}
	if m.Lt != nil {
		n += 1 + protohelpers.SizeOfZigzag(uint64(*m.Lt))
	}
	if m.Lte != nil {
		n += 1 + protohelpers.SizeOfZigzag(uint64(*m.Lte))
	}
	if m.Gt != nil {
		n += 1 + protohelpers.SizeOfZigzag(uint64(*m.Gt))
	}
	if m.Gte != nil {
		n += 1 + protohelpers.SizeOfZigzag(uint64(*m.Gte))
	}
	if len(m.In) > 0 {
		for _, e := range m.In {
			n += 1 + protohelpers.SizeOfZigzag(uint64(e))
		}
	}
	if len(m.NotIn) > 0 {
		for _, e := range m.NotIn {
			n += 1 + protohelpers.SizeOfZigzag(uint64(e))
		}
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *Fixed32Rules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 5
	}
	if m.Lt != nil {
		n += 5
	}
	if m.Lte != nil {
		n += 5
	}
	if m.Gt != nil {
		n += 5
	}
	if m.Gte != nil {
		n += 5
	}
	if len(m.In) > 0 {
		n += 5 * len(m.In)
	}
	if len(m.NotIn) > 0 {
		n += 5 * len(m.NotIn)
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *Fixed64Rules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 9
	}
	if m.Lt != nil {
		n += 9
	}
	if m.Lte != nil {
		n += 9
	}
	if m.Gt != nil {
		n += 9
	}
	if m.Gte != nil {
		n += 9
	}
	if len(m.In) > 0 {
		n += 9 * len(m.In)
	}
	if len(m.NotIn) > 0 {
		n += 9 * len(m.NotIn)
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *SFixed32Rules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 5
	}
	if m.Lt != nil {
		n += 5
	}
	if m.Lte != nil {
		n += 5
	}
	if m.Gt != nil {
		n += 5
	}
	if m.Gte != nil {
		n += 5
	}
	if len(m.In) > 0 {
		n += 5 * len(m.In)
	}
	if len(m.NotIn) > 0 {
		n += 5 * len(m.NotIn)
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *SFixed64Rules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 9
	}
	if m.Lt != nil {
		n += 9
	}
	if m.Lte != nil {
		n += 9
	}
	if m.Gt != nil {
		n += 9
	}
	if m.Gte != nil {
		n += 9
	}
	if len(m.In) > 0 {
		n += 9 * len(m.In)
	}
	if len(m.NotIn) > 0 {
		n += 9 * len(m.NotIn)
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *BoolRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *StringRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		l = len(*m.Const)
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.MinLen != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.MinLen))
	}
	if m.MaxLen != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.MaxLen))
	}
	if m.MinBytes != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.MinBytes))
	}
	if m.MaxBytes != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.MaxBytes))
	}
	if m.Pattern != nil {
		l = len(*m.Pattern)
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Prefix != nil {
		l = len(*m.Prefix)
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Suffix != nil {
		l = len(*m.Suffix)
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Contains != nil {
		l = len(*m.Contains)
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if len(m.In) > 0 {
		for _, s := range m.In {
			l = len(s)
			n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
		}
	}
	if len(m.NotIn) > 0 {
		for _, s := range m.NotIn {
			l = len(s)
			n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
		}
	}
	if vtmsg, ok := m.WellKnown.(interface{ SizeVT() int }); ok {
		n += vtmsg.SizeVT()
	}
	if m.Len != nil {
		n += 2 + protohelpers.SizeOfVarint(uint64(*m.Len))
	}
	if m.LenBytes != nil {
		n += 2 + protohelpers.SizeOfVarint(uint64(*m.LenBytes))
	}
	if m.NotContains != nil {
		l = len(*m.NotContains)
		n += 2 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Strict != nil {
		n += 3
	}
	if m.IgnoreEmpty != nil {
		n += 3
	}
	n += len(m.unknownFields)
	return n
}

func (m *StringRules_Email) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *StringRules_Hostname) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *StringRules_Ip) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *StringRules_Ipv4) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *StringRules_Ipv6) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *StringRules_Uri) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *StringRules_UriRef) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *StringRules_Address) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *StringRules_Uuid) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 3
	return n
}
func (m *StringRules_WellKnownRegex) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + protohelpers.SizeOfVarint(uint64(m.WellKnownRegex))
	return n
}
func (m *BytesRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		l = len(m.Const)
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.MinLen != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.MinLen))
	}
	if m.MaxLen != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.MaxLen))
	}
	if m.Pattern != nil {
		l = len(*m.Pattern)
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Prefix != nil {
		l = len(m.Prefix)
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Suffix != nil {
		l = len(m.Suffix)
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Contains != nil {
		l = len(m.Contains)
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if len(m.In) > 0 {
		for _, b := range m.In {
			l = len(b)
			n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
		}
	}
	if len(m.NotIn) > 0 {
		for _, b := range m.NotIn {
			l = len(b)
			n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
		}
	}
	if vtmsg, ok := m.WellKnown.(interface{ SizeVT() int }); ok {
		n += vtmsg.SizeVT()
	}
	if m.Len != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Len))
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *BytesRules_Ip) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *BytesRules_Ipv4) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *BytesRules_Ipv6) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *EnumRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Const != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.Const))
	}
	if m.DefinedOnly != nil {
		n += 2
	}
	if len(m.In) > 0 {
		for _, e := range m.In {
			n += 1 + protohelpers.SizeOfVarint(uint64(e))
		}
	}
	if len(m.NotIn) > 0 {
		for _, e := range m.NotIn {
			n += 1 + protohelpers.SizeOfVarint(uint64(e))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *MessageRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Skip != nil {
		n += 2
	}
	if m.Required != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *RepeatedRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinItems != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.MinItems))
	}
	if m.MaxItems != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.MaxItems))
	}
	if m.Unique != nil {
		n += 2
	}
	if m.Items != nil {
		l = m.Items.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *MapRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinPairs != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.MinPairs))
	}
	if m.MaxPairs != nil {
		n += 1 + protohelpers.SizeOfVarint(uint64(*m.MaxPairs))
	}
	if m.NoSparse != nil {
		n += 2
	}
	if m.Keys != nil {
		l = m.Keys.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Values != nil {
		l = m.Values.SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.IgnoreEmpty != nil {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *AnyRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Required != nil {
		n += 2
	}
	if len(m.In) > 0 {
		for _, s := range m.In {
			l = len(s)
			n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
		}
	}
	if len(m.NotIn) > 0 {
		for _, s := range m.NotIn {
			l = len(s)
			n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *DurationRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Required != nil {
		n += 2
	}
	if m.Const != nil {
		l = (*durationpb1.Duration)(m.Const).SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Lt != nil {
		l = (*durationpb1.Duration)(m.Lt).SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Lte != nil {
		l = (*durationpb1.Duration)(m.Lte).SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Gt != nil {
		l = (*durationpb1.Duration)(m.Gt).SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Gte != nil {
		l = (*durationpb1.Duration)(m.Gte).SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if len(m.In) > 0 {
		for _, e := range m.In {
			l = (*durationpb1.Duration)(e).SizeVT()
			n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
		}
	}
	if len(m.NotIn) > 0 {
		for _, e := range m.NotIn {
			l = (*durationpb1.Duration)(e).SizeVT()
			n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *TimestampRules) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Required != nil {
		n += 2
	}
	if m.Const != nil {
		l = (*timestamppb1.Timestamp)(m.Const).SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Lt != nil {
		l = (*timestamppb1.Timestamp)(m.Lt).SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Lte != nil {
		l = (*timestamppb1.Timestamp)(m.Lte).SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Gt != nil {
		l = (*timestamppb1.Timestamp)(m.Gt).SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.Gte != nil {
		l = (*timestamppb1.Timestamp)(m.Gte).SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	if m.LtNow != nil {
		n += 2
	}
	if m.GtNow != nil {
		n += 2
	}
	if m.Within != nil {
		l = (*durationpb1.Duration)(m.Within).SizeVT()
		n += 1 + l + protohelpers.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *FieldRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Float); ok {
				if err := oneof.Float.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &FloatRules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Float{Float: v}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Double", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Double); ok {
				if err := oneof.Double.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &DoubleRules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Double{Double: v}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Int32); ok {
				if err := oneof.Int32.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &Int32Rules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Int32{Int32: v}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Int64); ok {
				if err := oneof.Int64.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &Int64Rules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Int64{Int64: v}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Uint32); ok {
				if err := oneof.Uint32.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &UInt32Rules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Uint32{Uint32: v}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Uint64); ok {
				if err := oneof.Uint64.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &UInt64Rules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Uint64{Uint64: v}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sint32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Sint32); ok {
				if err := oneof.Sint32.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &SInt32Rules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Sint32{Sint32: v}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sint64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Sint64); ok {
				if err := oneof.Sint64.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &SInt64Rules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Sint64{Sint64: v}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Fixed32); ok {
				if err := oneof.Fixed32.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &Fixed32Rules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Fixed32{Fixed32: v}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Fixed64); ok {
				if err := oneof.Fixed64.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &Fixed64Rules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Fixed64{Fixed64: v}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed32", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Sfixed32); ok {
				if err := oneof.Sfixed32.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &SFixed32Rules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Sfixed32{Sfixed32: v}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sfixed64", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Sfixed64); ok {
				if err := oneof.Sfixed64.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &SFixed64Rules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Sfixed64{Sfixed64: v}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Bool); ok {
				if err := oneof.Bool.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &BoolRules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Bool{Bool: v}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_String_); ok {
				if err := oneof.String_.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &StringRules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_String_{String_: v}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Bytes); ok {
				if err := oneof.Bytes.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &BytesRules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Bytes{Bytes: v}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Enum); ok {
				if err := oneof.Enum.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &EnumRules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Enum{Enum: v}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &MessageRules{}
			}
			if err := m.Message.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repeated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Repeated); ok {
				if err := oneof.Repeated.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &RepeatedRules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Repeated{Repeated: v}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Map); ok {
				if err := oneof.Map.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &MapRules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Map{Map: v}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Any", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Any); ok {
				if err := oneof.Any.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &AnyRules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Any{Any: v}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Duration); ok {
				if err := oneof.Duration.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &DurationRules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Duration{Duration: v}
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Type.(*FieldRules_Timestamp); ok {
				if err := oneof.Timestamp.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &TimestampRules{}
				if err := v.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Type = &FieldRules_Timestamp{Timestamp: v}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Const = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Lt = &v2
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Lte = &v2
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Gt = &v2
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			v2 := float32(math.Float32frombits(v))
			m.Gte = &v2
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.In = append(m.In, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.In = append(m.In, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.NotIn = append(m.NotIn, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.NotIn = append(m.NotIn, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Const = &v2
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Lt = &v2
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Lte = &v2
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Gt = &v2
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.Gte = &v2
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.In = append(m.In, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.In = append(m.In, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 7:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.NotIn = append(m.NotIn, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.NotIn = append(m.NotIn, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Int32Rules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int32Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int32Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Const = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lt = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lte = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gt = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gte = &v
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.In = append(m.In, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.In = append(m.In, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NotIn = append(m.NotIn, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NotIn = append(m.NotIn, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Int64Rules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int64Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int64Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Const = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lt = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lte = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gt = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gte = &v
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.In = append(m.In, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.In = append(m.In, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NotIn = append(m.NotIn, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NotIn = append(m.NotIn, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UInt32Rules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UInt32Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UInt32Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Const = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lt = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lte = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gt = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gte = &v
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.In = append(m.In, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.In = append(m.In, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NotIn = append(m.NotIn, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NotIn = append(m.NotIn, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UInt64Rules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UInt64Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UInt64Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Const = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lt = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lte = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gt = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Gte = &v
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.In = append(m.In, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.In = append(m.In, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NotIn = append(m.NotIn, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NotIn = append(m.NotIn, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SInt32Rules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SInt32Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SInt32Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Const = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Lt = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Lte = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Gt = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Gte = &v
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.In = append(m.In, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.In = append(m.In, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.NotIn = append(m.NotIn, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.NotIn = append(m.NotIn, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SInt64Rules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SInt64Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SInt64Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Const = &v2
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Lt = &v2
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Lte = &v2
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Gt = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Gte = &v2
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.In = append(m.In, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.In = append(m.In, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.NotIn = append(m.NotIn, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.NotIn = append(m.NotIn, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fixed32Rules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fixed32Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fixed32Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Const = &v
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Lt = &v
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Lte = &v
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Gt = &v
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Gte = &v
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.In = append(m.In, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.In = append(m.In, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.NotIn = append(m.NotIn, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.NotIn = append(m.NotIn, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fixed64Rules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fixed64Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fixed64Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Const = &v
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lt = &v
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lte = &v
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gt = &v
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gte = &v
		case 6:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.In = append(m.In, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.In = append(m.In, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 7:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.NotIn = append(m.NotIn, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.NotIn = append(m.NotIn, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SFixed32Rules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SFixed32Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SFixed32Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Const = &v
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Lt = &v
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Lte = &v
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Gt = &v
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v int32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Gte = &v
		case 6:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.In = append(m.In, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.In = append(m.In, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 7:
			if wireType == 5 {
				var v int32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				m.NotIn = append(m.NotIn, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = int32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					m.NotIn = append(m.NotIn, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SFixed64Rules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SFixed64Rules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SFixed64Rules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Const = &v
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var v int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lt = &v
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var v int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lte = &v
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var v int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gt = &v
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var v int64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Gte = &v
		case 6:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.In = append(m.In, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.In = append(m.In, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 7:
			if wireType == 1 {
				var v int64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				m.NotIn = append(m.NotIn, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					m.NotIn = append(m.NotIn, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoolRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoolRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoolRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Const = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Const = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLen", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinLen = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLen", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxLen = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinBytes = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxBytes = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Pattern = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Prefix = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Suffix = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Contains = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.In = append(m.In, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotIn = append(m.NotIn, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WellKnown = &StringRules_Email{Email: b}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WellKnown = &StringRules_Hostname{Hostname: b}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WellKnown = &StringRules_Ip{Ip: b}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WellKnown = &StringRules_Ipv4{Ipv4: b}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WellKnown = &StringRules_Ipv6{Ipv6: b}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WellKnown = &StringRules_Uri{Uri: b}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UriRef", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WellKnown = &StringRules_UriRef{UriRef: b}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Len = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LenBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LenBytes = &v
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WellKnown = &StringRules_Address{Address: b}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WellKnown = &StringRules_Uuid{Uuid: b}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotContains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NotContains = &s
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WellKnownRegex", wireType)
			}
			var v KnownRegex
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= KnownRegex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WellKnown = &StringRules_WellKnownRegex{WellKnownRegex: v}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Strict = &b
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BytesRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BytesRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BytesRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Const = append(m.Const[:0], dAtA[iNdEx:postIndex]...)
			if m.Const == nil {
				m.Const = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLen", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinLen = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLen", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxLen = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Pattern = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix[:0], dAtA[iNdEx:postIndex]...)
			if m.Prefix == nil {
				m.Prefix = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suffix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Suffix = append(m.Suffix[:0], dAtA[iNdEx:postIndex]...)
			if m.Suffix == nil {
				m.Suffix = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contains", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contains = append(m.Contains[:0], dAtA[iNdEx:postIndex]...)
			if m.Contains == nil {
				m.Contains = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.In = append(m.In, make([]byte, postIndex-iNdEx))
			copy(m.In[len(m.In)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotIn = append(m.NotIn, make([]byte, postIndex-iNdEx))
			copy(m.NotIn[len(m.NotIn)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WellKnown = &BytesRules_Ip{Ip: b}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WellKnown = &BytesRules_Ipv4{Ipv4: b}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WellKnown = &BytesRules_Ipv6{Ipv6: b}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Len = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnumRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Const = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinedOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.DefinedOnly = &b
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.In = append(m.In, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.In) == 0 {
					m.In = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.In = append(m.In, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NotIn = append(m.NotIn, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protohelpers.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protohelpers.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protohelpers.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NotIn) == 0 {
					m.NotIn = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protohelpers.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NotIn = append(m.NotIn, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Skip = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Required = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepeatedRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepeatedRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepeatedRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinItems", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinItems = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxItems", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxItems = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Unique = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = &FieldRules{}
			}
			if err := m.Items.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPairs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MinPairs = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPairs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxPairs = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoSparse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NoSparse = &b
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Keys == nil {
				m.Keys = &FieldRules{}
			}
			if err := m.Keys.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Values == nil {
				m.Values = &FieldRules{}
			}
			if err := m.Values.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IgnoreEmpty = &b
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnyRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Required = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.In = append(m.In, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotIn = append(m.NotIn, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DurationRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DurationRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DurationRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Required = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Const == nil {
				m.Const = &durationpb.Duration{}
			}
			if err := (*durationpb1.Duration)(m.Const).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lt == nil {
				m.Lt = &durationpb.Duration{}
			}
			if err := (*durationpb1.Duration)(m.Lt).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lte == nil {
				m.Lte = &durationpb.Duration{}
			}
			if err := (*durationpb1.Duration)(m.Lte).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gt == nil {
				m.Gt = &durationpb.Duration{}
			}
			if err := (*durationpb1.Duration)(m.Gt).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gte == nil {
				m.Gte = &durationpb.Duration{}
			}
			if err := (*durationpb1.Duration)(m.Gte).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.In = append(m.In, &durationpb.Duration{})
			if err := (*durationpb1.Duration)(m.In[len(m.In)-1]).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotIn = append(m.NotIn, &durationpb.Duration{})
			if err := (*durationpb1.Duration)(m.NotIn[len(m.NotIn)-1]).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimestampRules) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protohelpers.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimestampRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimestampRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Required = &b
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Const == nil {
				m.Const = &timestamppb.Timestamp{}
			}
			if err := (*timestamppb1.Timestamp)(m.Const).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lt == nil {
				m.Lt = &timestamppb.Timestamp{}
			}
			if err := (*timestamppb1.Timestamp)(m.Lt).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lte == nil {
				m.Lte = &timestamppb.Timestamp{}
			}
			if err := (*timestamppb1.Timestamp)(m.Lte).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gt == nil {
				m.Gt = &timestamppb.Timestamp{}
			}
			if err := (*timestamppb1.Timestamp)(m.Gt).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gte", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gte == nil {
				m.Gte = &timestamppb.Timestamp{}
			}
			if err := (*timestamppb1.Timestamp)(m.Gte).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LtNow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.LtNow = &b
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GtNow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.GtNow = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Within", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protohelpers.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protohelpers.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protohelpers.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Within == nil {
				m.Within = &durationpb.Duration{}
			}
			if err := (*durationpb1.Duration)(m.Within).UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protohelpers.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protohelpers.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
